import path from "node:path";
import fs from "fs-extra";
import { glob } from "glob";
import type { PackageJson, ProjectOptions, TemplateVariable } from "./types.js";

export function validateProjectName(name: string): boolean {
	// Valid npm package name regex
	const validNameRegex =
		/^(?:@[a-z0-9-*~][a-z0-9-*._~]*\/)?[a-z0-9-~][a-z0-9-._~]*$/;

	return (
		validNameRegex.test(name) &&
		name.length <= 214 &&
		!name.startsWith(".") &&
		!name.startsWith("_") &&
		name === name.toLowerCase() &&
		!name.includes(" ")
	);
}

export async function replaceTemplateVariables(
	projectPath: string,
	pattern: string,
	variables: TemplateVariable,
): Promise<void> {
	try {
		const files = await glob(pattern, {
			cwd: projectPath,
			ignore: ["node_modules/**", ".git/**"],
		});

		for (const file of files) {
			const filePath = path.join(projectPath, file);

			if (await fs.pathExists(filePath)) {
				const stat = await fs.stat(filePath);
				if (stat.isFile()) {
					let content = await fs.readFile(filePath, "utf8");

					// Replace template variables
					for (const [key, value] of Object.entries(variables)) {
						const regex = new RegExp(`{{\\s*${key}\\s*}}`, "g");
						content = content.replace(regex, String(value));
					}

					await fs.writeFile(filePath, content);
				}
			}
		}
	} catch (error) {
		// Ignore glob errors for non-existent patterns
		console.warn(`Warning: Pattern ${pattern} did not match any files`);
	}
}

export async function updatePackageJson(
	projectPath: string,
	projectName: string,
	options: ProjectOptions,
): Promise<void> {
	const packageJsonPath = path.join(projectPath, "package.json");

	if (await fs.pathExists(packageJsonPath)) {
		const packageJson: PackageJson = await fs.readJson(packageJsonPath);

		// Update basic info
		packageJson.name = projectName;
		packageJson.version = "0.1.0";
		packageJson.description =
			packageJson.description ||
			`${projectName} - Generated by create-my-bun-app`;

		// Remove template-specific fields
		packageJson.repository = undefined;
		packageJson.bugs = undefined;
		packageJson.homepage = undefined;

		// Update scripts based on package manager
		if (packageJson.scripts) {
			const scripts = packageJson.scripts;

			// Update package manager commands
			if (options.packageManager !== "bun") {
				// biome-ignore lint/complexity/noForEach: <explanation>
				Object.keys(scripts).forEach((script) => {
					if (scripts[script]?.includes("bun ")) {
						scripts[script] = scripts[script]?.replace(
							/bun /g,
							`${options.packageManager} `,
						);
					}
				});
			}

			// Add feature-specific scripts
			if (options.features.includes("linting")) {
				scripts.lint = "eslint . --ext .js,.jsx,.ts,.tsx";
				scripts["lint:fix"] = "eslint . --ext .js,.jsx,.ts,.tsx --fix";
				scripts.format = "prettier --write .";
			}

			if (options.features.includes("biome")) {
				scripts.lint = "biome check .";
				scripts["lint:fix"] = "biome check . --apply";
				scripts.format = "biome format . --write";
			}

			if (options.features.includes("testing")) {
				scripts.test = "bun test";
				scripts["test:watch"] = "bun test --watch";
				scripts["test:coverage"] = "bun test --coverage";
			}

			if (options.features.includes("turborepo")) {
				scripts.build = "turbo run build";
				scripts.dev = "turbo run dev --parallel";
				scripts.lint = "turbo run lint";
				scripts.test = "turbo run test";
			}
		}

		// Add workspace configuration for monorepos
		if (["basic", "fullstack", "microservices"].includes(options.template)) {
			packageJson.workspaces = ["apps/*", "packages/*"];
		}

		await fs.writeJson(packageJsonPath, packageJson, { spaces: 2 });
	}
}

export async function updateTsConfig(
	projectPath: string,
	options: ProjectOptions,
): Promise<void> {
	const tsConfigPath = path.join(projectPath, "tsconfig.json");

	const tsConfig = {
		compilerOptions: {
			target: "ES2022",
			module: "ESNext",
			moduleResolution: "bundler",
			allowImportingTsExtensions: true,
			allowSyntheticDefaultImports: true,
			esModuleInterop: true,
			forceConsistentCasingInFileNames: true,
			strict: true,
			noUncheckedIndexedAccess: true,
			skipLibCheck: true,
			resolveJsonModule: true,
			allowJs: true,
			jsx: options.template === "pro" ? "react-jsx" : undefined,
			composite: options.features.includes("turborepo"),
			incremental: true,
		},
		include: ["**/*.ts", "**/*.tsx"],
		exclude: ["node_modules", "dist", "build"],
	};

	// Remove undefined values
	// biome-ignore lint/complexity/noForEach: <explanation>
	Object.keys(tsConfig.compilerOptions).forEach((key) => {
		if ((tsConfig.compilerOptions as any)[key] === undefined) {
			delete (tsConfig.compilerOptions as any)[key];
		}
	});

	await fs.writeJson(tsConfigPath, tsConfig, { spaces: 2 });
}

export async function createGitIgnore(
	projectPath: string,
	options: ProjectOptions,
): Promise<void> {
	const gitIgnoreContent = `
# Dependencies
node_modules/
.pnp
.pnp.js

# Testing
coverage/

# Build outputs
dist/
build/
.next/

# Environment variables
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# Logs
npm-debug.log*
yarn-debug.log*
yarn-error.log*
bun.lockb

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# IDE
.vscode/
.idea/
*.swp
*.swo
*~

# OS
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Turborepo
.turbo/

# Docker
.dockerignore

${options.features.includes("docker") ? "# Docker volumes\ndocker-data/\n" : ""}
${options.features.includes("changesets") ? "# Changesets\n.changeset/**/*.md\n" : ""}
`.trim();

	await fs.writeFile(path.join(projectPath, ".gitignore"), gitIgnoreContent);
}

export function getPackageManagerCommand(packageManager: string): string {
	const commands: Record<string, string> = {
		bun: "bun",
		npm: "npm run",
		yarn: "yarn",
		pnpm: "pnpm",
	};

	return commands[packageManager] || "bun";
}

export function formatProjectName(name: string): string {
	return name
		.toLowerCase()
		.replace(/[^a-z0-9-]/g, "-")
		.replace(/^-+|-+$/g, "")
		.replace(/-+/g, "-");
}
